import {UpdateHandler} from './UpdateHandler';
import {LcEntryGeometryValue} from '../../../../model/geometry/LcEntryGeometryValue';
import {EntryValueApiService} from '../../entry-value-api.service';
import {EventEmitter} from '@angular/core';
import {LcEntryType} from '../../../../../label-config/model/LcEntryType';
import {take, takeUntil} from 'rxjs/operators';
import {EntryChangeService} from '../../../entry-change.service';
import {LcEntryValueUpdateFactory} from '../../../../model/LcEntryValueUpdateFactory';
import {VideoControlService} from '../../../video-control.service';
import {forkJoin, Observable} from 'rxjs';
import {VideoUpdateHelper} from './helper/VideoUpdateHelper';


export class VideoUpdateHandler extends UpdateHandler {

  public constructor(
    labelTaskId: string,
    entryValueApiService: EntryValueApiService,
    private changeApi: EntryChangeService,
    private videoControl: VideoControlService,
    private onUpdateValue: EventEmitter<LcEntryGeometryValue>
  ) {
    super(labelTaskId, entryValueApiService);
  }

  /**
   * On video values we care about the optional given change object.
   * If this one is passed from outside, we'll commit this one to the BE.
   * Otherwise we create a new instance with the current value data.
   *
   * @param value
   */
  public updateGeometry(value: LcEntryGeometryValue): void {

    if ([
      LcEntryType.IMAGE_SEGMENTATION, // This type is not supported within the video labeling
      LcEntryType.IMAGE_SEGMENTATION_ERASER, // This type is not supported in the BE in any way.
    ].includes(value.kind)) {
      return;
    }

    const newCreated = value.change.length === 0;
    if (newCreated) {
      // This should not be possible!
      return;
    }

    const updateHelper = new VideoUpdateHelper(this.changeApi, this.videoControl.currentFrameNumber);

    forkJoin([
      this.updateGeometryValue(value),
      updateHelper.handleChangeOnValue(value),
      updateHelper.updateFollowingAutoGeneratedChange(value)
    ]).pipe(
      take(1),
      takeUntil(this.unsubscribe)
    ).subscribe(([_, changeResponse, next]) => {
      value.addChange(changeResponse);
      value.addChange(next);
      this.onUpdateValue.emit(value);
    });
  }

  /**
   * @deprecated Create a separate method within the 'EntryValueService' to update the comment only when it's necessary.
   */
  private updateGeometryValue(value: LcEntryGeometryValue): Observable<LcEntryGeometryValue> {
    const data = LcEntryValueUpdateFactory.prepare(this.labelTaskId).geometry(value);
    return this.entryValueApiService.updateSingleValue(value.id, data) as Observable<LcEntryGeometryValue>;
  }
}
