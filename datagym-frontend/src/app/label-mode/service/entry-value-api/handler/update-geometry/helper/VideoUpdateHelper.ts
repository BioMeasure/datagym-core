import {Observable, of} from 'rxjs';
import {LcEntryChange} from '../../../../../model/change/LcEntryChange';
import {LcEntryGeometryValue} from '../../../../../model/geometry/LcEntryGeometryValue';
import {EntryChangeService} from '../../../../entry-change.service';
import {LcEntryChangeFactory} from '../../../../../model/change/LcEntryChangeFactory';
import {LcEntryChangeType} from '../../../../../model/change/LcEntryChangeType';


export class VideoUpdateHelper {

  readonly isOk: boolean;

  public constructor(
    private changeApi: EntryChangeService,
    public readonly frameNumber: number
  ) { }

  public handleChangeOnValue(value: LcEntryGeometryValue): Observable<LcEntryChange> {

    const change = value.change.find(c => c.frameNumber === this.frameNumber);

    return change === undefined
      ? this.createChange(value, this.frameNumber)
      : this.updateChange(value, change);
  }

  public updateFollowingAutoGeneratedChange(value: LcEntryGeometryValue): Observable<LcEntryChange|null> {

    // The frameNumbers should be ordered.
    const frameNumbers = value.frameNumbers;
    const followingFrameNumber = frameNumbers.find(n => n > this.frameNumber);
    if (followingFrameNumber === undefined) {
      // Respect also the last frame.
      return of(null);
    }

    const followingChange = value.change.find(c => c.frameNumber === followingFrameNumber);
    if (!/*not*/!!followingChange || followingChange.handCrafted) {
      // Don't update handCrafted change objects.
      // Note: after reloading, all changes are marked as 'handCrafted'
      return of(null);
    }

    const updatedChange = (new LcEntryChangeFactory({...followingChange})).fromValue(value);

    return this.changeApi.update(updatedChange);
  }

  /**
   * Create a new keyframe of type CHANGE.
   */
  private createChange(value: LcEntryGeometryValue, currentFrameNumber: number): Observable<LcEntryChange> {

    const newChange = (new LcEntryChangeFactory({
      type: LcEntryChangeType.CHANGE,
      frameNumber: currentFrameNumber
    })).fromValue(value);

    return this.changeApi.create(value, newChange);
  }

  /**
   * Update the change object when it's already known within the BE.
   *
   * Keep the id, frameType and frameNumber but update the geometry properties.
   *
   * @param value Read the geometry properties from this value.
   * @param change The 'old' change object.
   * @private
   */
  private updateChange(value: LcEntryGeometryValue, change: LcEntryChange): Observable<LcEntryChange> {

    const newChange = (new LcEntryChangeFactory({
      id: change.id,
      type: change.frameType,
      frameNumber: change.frameNumber
    })).fromValue(value);

    return this.changeApi.update(newChange);
  }

}
